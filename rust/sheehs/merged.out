================ src/file.rs STARTS HERE
use std::{fs, io, io::ErrorKind};

use crate::util;

pub struct File {
    pub name: String,
    pub data: String,
}

impl File {
    pub fn new(name: String) -> Result<Self, io::Error> {
        let data = fs::read_to_string(&name)?;

        Ok(Self { name, data })
    }

    pub fn create(name: String, data: String, is_overwrite: bool) -> Result<File, io::Error> {
        if util::is_file(&name) && !is_overwrite {
            return Err(io::Error::new(
                ErrorKind::AlreadyExists,
                format!("File {} already exists.", name),
            ));
        }

        fs::write(&name, data)?;

        Ok(Self::new(name)?)
    }
}

================ src/file.rs ENDS HERE

================ src/lib.rs STARTS HERE
mod file;
pub mod merger;
mod util;

================ src/lib.rs ENDS HERE

================ src/main.rs STARTS HERE
use sheehs::merger;

fn main() {
    merger::run();
}

================ src/main.rs ENDS HERE

================ src/merger.rs STARTS HERE
use crate::{file, util};
use std::io;

fn merge(
    files: &[file::File],
    output: &String,
    is_overwrite: bool,
) -> Result<file::File, io::Error> {
    file::File::create(
        output.clone(),
        files.iter().map(fmt_data).collect(),
        is_overwrite,
    )
}

fn fmt_data(file: &file::File) -> String {
    let separator = "=".repeat(16);
    format!(
        "{0} {1} STARTS HERE\n{2}\n{0} {1} ENDS HERE\n\n",
        separator, file.name, file.data
    )
}

pub fn run() {
    let args: Vec<String> = std::env::args().skip(1).collect();

    if args.is_empty() {
        eprintln!("Not enough arguments.");
        std::process::exit(1);
    }

    let files: Result<Vec<file::File>, io::Error> = args
        .iter()
        .filter_map(|f| util::is_file(f).then(|| file::File::new(f.to_string())))
        .collect();

    let name = String::from("merged.out");
    let is_overwrite = true;

    match files {
        Ok(files) => {
            match merge(&files, &name, is_overwrite) {
                Ok(_) => println!("=> Merged files into {}", name),
                Err(e) => {
                    eprintln!("=> Error: {}", e);
                    std::process::exit(1);
                }
            };
        }
        Err(e) => {
            eprintln!("Error reading file: {}", e);
            std::process::exit(1);
        }
    }
}

================ src/merger.rs ENDS HERE

================ src/util.rs STARTS HERE
use std::path;

pub fn is_file(file: &String) -> bool {
    path::Path::new(file).is_file()
}

================ src/util.rs ENDS HERE

